using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Editor
{
    public class NativeTypes
    {
        #region Native structs
        [StructLayout(LayoutKind.Sequential)]
        public struct Matrix
        {
            float _11, _12, _13, _14;
            float _21, _22, _23, _24;
            float _31, _32, _33, _34;
            float _41, _42, _43, _44;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct Handle
        {
            public ushort instance;
            public ushort index;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct Error
        {
            public string message;
        }
        #endregion Native structs

        // TODO: Load this in from meta file generated by the engine
        public enum EType
        {
            Int     = 0,
            Uint    = 1,
            Short   = 2,
            UShort  = 3,
            Char    = 4,
            UChar   = 5,
            Float   = 6,
            Double  = 7,
            Bool    = 8,
            String  = 9,
            WString = 10,
            Vector3 = 11,
            Matrix  = 12,
            AABB    = 13,
            Class   = 14,
            Array   = 15,
            Pointer = 16
        };

        #region Type Map
        public static Dictionary<EType, Type> Types = new Dictionary<EType, Type>()
        {
            { EType.Int, typeof(int) },
            { EType.Uint, typeof(uint) },
            { EType.Short, typeof(short) },
            { EType.UShort, typeof(ushort) },
            { EType.Char, typeof(sbyte) }, // using sbyte since char in c# is 16bit
            { EType.UChar, typeof(byte) },
            { EType.Float, typeof(float) },
            { EType.Double, typeof(double) },
            { EType.Bool, typeof(bool) },
            { EType.String, typeof(string) },
            { EType.WString, typeof(string) }, // string in c# is wide char
            { EType.Vector3, typeof(Vector3) },
            { EType.Matrix, typeof(Matrix) },
            { EType.AABB, typeof(AABB) },
            { EType.Class, typeof(object) }, // todo
            { EType.Array, typeof(Array) },
            { EType.Pointer, typeof(object) } // todo
        };
        #endregion Type Map

        #region Type conversion methods
        public static Type GetType(int t)
        {
            return Types[(EType)t];
        }

        public static object ConvertToType(byte[] bytes, int type)
        {
            EType eType = (EType)type;
            switch (eType)
            {
                case EType.Int: 
                    return BitConverter.ToInt32(bytes, 0);
                case EType.Uint:
                    return BitConverter.ToUInt32(bytes, 0);
                case EType.Short:
                    return BitConverter.ToInt16(bytes, 0);
                case EType.UShort:
                    return BitConverter.ToUInt16(bytes, 0);
                case EType.Char:
                    return Convert.ToSByte(bytes[0]);
                case EType.UChar:
                    return bytes[0];
                case EType.Float:
                    return BitConverter.ToSingle(bytes, 0);
                case EType.Double:
                    return BitConverter.ToDouble(bytes, 0);
                case EType.Bool:
                    return BitConverter.ToBoolean(bytes, 0);
                case EType.String:
                    {
                        SerializeIn sIn = new SerializeIn(bytes);
                        return sIn.ReadStringLE();
                    }
                case EType.Vector3:
                    {
                        Vector3 v = new Vector3();
                        return (Vector3)bytes;
                    }
            }
            return Convert.ChangeType(bytes, GetType(type));
        }

        public static byte[] ConvertToBytes(object obj, int type)
        {
            EType eType = (EType)type;
            switch (eType)
            {
                case EType.Int: 
                    return BitConverter.GetBytes((int)obj);
                case EType.Uint:
                    return BitConverter.GetBytes((uint)obj);
                case EType.Short:
                    return BitConverter.GetBytes((short)obj);
                case EType.UShort:
                    return BitConverter.GetBytes((ushort)obj);
                case EType.Char:
                    return BitConverter.GetBytes((sbyte)obj);
                case EType.UChar:
                    return BitConverter.GetBytes((byte)obj);
                case EType.Float:
                    return BitConverter.GetBytes((float)obj);
                case EType.Double:
                    return BitConverter.GetBytes((double)obj);
                case EType.Bool:
                    return BitConverter.GetBytes((bool)obj);
                case EType.String:
                case EType.WString:
                    {
                        // Length encode the string
                        string str = obj.ToString();
                        byte[] bytes = new byte[str.Length + sizeof(uint)];
                        SerializeOut sOut = new SerializeOut(bytes);
                        sOut.WriteStringLE(str);
                        return bytes;
                    }
                case EType.Vector3:
                    {
                        Vector3 v = new Vector3();
                        return v.ToBytes();
                    }
            }
            Debug.Assert(false);
            return null;
        }
        #endregion Type conversion methods
    }
}
